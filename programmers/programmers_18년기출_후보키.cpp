#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> CKey;

int index2[28][2] = {
	{ 0, 1 },{ 0, 2 },{ 0, 3 },{ 0, 4 },{ 0, 5 },{ 0, 6 },{ 0, 7 },
{ 1, 2 },{ 1, 3 },{ 1, 4 },{ 1, 5 },{ 1, 6 },{ 1, 7 },
{ 2, 3 },{ 2, 4 },{ 2, 5 },{ 2, 6 },{ 2, 7 },
{ 3, 4 },{ 3, 5 },{ 3, 6 },{ 3, 7 },
{ 4, 5 },{ 4, 6 },{ 4, 7 },
{ 5, 6 },{ 5, 7 },
{ 6, 7 }
};

int index3[56][3] = {
	{ 0, 1, 2 },{ 0, 1, 3 },{ 0, 1, 4 },{ 0, 1, 5 },{ 0, 1, 6 },{ 0, 1, 7 },
{ 0, 2, 3 },{ 0, 2, 4 },{ 0, 2, 5 },{ 0, 2, 6 },{ 0, 2, 7 },
{ 0, 3, 4 },{ 0, 3, 5 },{ 0, 3, 6 },{ 0, 3, 7 },
{ 0, 4, 5 },{ 0, 4, 6 },{ 0, 4, 7 },
{ 0, 5, 6 },{ 0, 5, 7 },
{ 0, 6, 7 },
{ 1, 2, 3 },{ 1, 2, 4 },{ 1, 2, 5 },{ 1, 2, 6 },{ 1, 2, 7 },
{ 1, 3, 4 },{ 1, 3, 5 },{ 1, 3, 6 },{ 1, 3, 7 },
{ 1, 4, 5 },{ 1, 4, 6 },{ 1, 4, 7 },
{ 1, 5, 6 },{ 1, 5, 7 },
{ 1, 6, 7 },
{ 2, 3, 4 },{ 2, 3, 5 },{ 2, 3, 6 },{ 2, 3, 7 },
{ 2, 4, 5 },{ 2, 4, 6 },{ 2, 4, 7 },
{ 2, 5, 6 },{ 2, 5, 7 },
{ 2, 6, 7 },
{ 3, 4, 5 },{ 3, 4, 6 },{ 3, 4, 7 },
{ 3, 5, 6 },{ 3, 5, 7 },
{ 3, 6, 7 },
{ 4, 5, 6 },{ 4, 5, 7 },
{ 4, 6, 7 },
{ 5, 6, 7 }
};

int index4[70][4] = {
	{ 0, 1, 2, 3 },{ 0, 1, 2, 4 },{ 0, 1, 2, 5 },{ 0, 1, 2, 6 },{ 0, 1, 2, 7 },
{ 0, 1, 3, 4 },{ 0, 1, 3, 5 },{ 0, 1, 3, 6 },{ 0, 1, 3, 7 },
{ 0, 1, 4, 5 },{ 0, 1, 4, 6 },{ 0, 1, 4, 7 },
{ 0, 1, 5, 6 },{ 0, 1, 5, 7 },
{ 0, 1, 6, 7 },
{ 0, 2, 3, 4 },{ 0, 2, 3, 5 },{ 0, 2, 3, 6 },{ 0, 2, 3, 7 },
{ 0, 2, 4, 5 },{ 0, 2, 4, 6 },{ 0, 2, 4, 7 },
{ 0, 2, 5, 6 },{ 0, 2, 5, 7 },
{ 0, 2, 6, 7 },
{ 0, 3, 4, 5 },{ 0, 3, 4, 6 },{ 0, 3, 4, 7 },
{ 0, 3, 5, 6 },{ 0, 3, 5, 7 },
{ 0, 3, 6, 7 },
{ 0, 4, 5, 6 },{ 0, 4, 5, 7 },
{ 0, 4, 6, 7 },
{ 0, 5, 6, 7 },
{ 1, 2, 3, 4 },{ 1, 2, 3, 5 },{ 1, 2, 3, 6 },{ 1, 2, 3, 7 },
{ 1, 2, 4, 5 },{ 1, 2, 4, 6 },{ 1, 2, 4, 7 },
{ 1, 2, 5, 6 },{ 1, 2, 5, 7 },
{ 1, 2, 6, 7 },
{ 1, 3, 4, 5 },{ 1, 3, 4, 6 },{ 1, 3, 4, 7 },
{ 1, 3, 5, 6 },{ 1, 3, 5, 7 },
{ 1, 3, 6, 7 },
{ 1, 4, 5, 6 },{ 1, 4, 5, 7 },
{ 1, 4, 6, 7 },
{ 1, 5, 6, 7 },
{ 2, 3, 4, 5 },{ 2, 3, 4, 6 },{ 2, 3, 4, 7 },
{ 2, 3, 5, 6 },{ 2, 3, 5, 7 },
{ 2, 3, 6, 7 },
{ 2, 4, 5, 6 },{ 2, 4, 5, 7 },
{ 2, 4, 6, 7 },
{ 2, 5, 6, 7 },
{ 3, 4, 5, 6 },{ 3, 4, 5, 7 },
{ 3, 4, 6, 7 },
{ 3, 5, 6, 7 },
{ 4, 5, 6, 7 }
};


int index5[56][5] = {
	{ 0, 1, 2, 3, 4 },{ 0, 1, 2, 3, 5 },{ 0, 1, 2, 3, 6 },{ 0, 1, 2, 3, 7 },
{ 0, 1, 2, 4, 5 },{ 0, 1, 2, 4, 6 },{ 0, 1, 2, 4, 7 },
{ 0, 1, 2, 5, 6 },{ 0, 1, 2, 5, 7 },
{ 0, 1, 2, 6, 7 },
{ 0, 1, 3, 4, 5 },{ 0, 1, 3, 4, 6 },{ 0, 1, 3, 4, 7 },
{ 0, 1, 3, 5, 6 },{ 0, 1, 3, 5, 7 },
{ 0, 1, 3, 6, 7 },
{ 0, 1, 4, 5, 6 },{ 0, 1, 4, 5, 7 },
{ 0, 1, 4, 6, 7 },
{ 0, 1, 5, 6, 7 },
{ 0, 2, 3, 4, 5 },{ 0, 2, 3, 4, 6 },{ 0, 2, 3, 4, 7 },
{ 0, 2, 3, 5, 6 },{ 0, 2, 3, 5, 7 },
{ 0, 2, 3, 6, 7 },
{ 0, 2, 4, 5, 6 },{ 0, 2, 4, 5, 7 },
{ 0, 2, 4, 6, 7 },
{ 0, 2, 5, 6, 7 },
{ 0, 3, 4, 5, 6 },{ 0, 3, 4, 5, 7 },
{ 0, 3, 4, 6, 7 },
{ 0, 3, 5, 6, 7 },
{ 0, 4, 5, 6, 7 },
{ 1, 2, 3, 4, 5 },{ 1, 2, 3, 4, 6 },{ 1, 2, 3, 4, 7 },
{ 1, 2, 3 ,5, 6 },{ 1, 2, 3, 5, 7 },
{ 1, 2, 3, 6, 7 },
{ 1, 2, 4, 5, 6 },{ 1, 2, 4, 5, 7 },
{ 1, 2, 4, 6, 7 },
{ 1, 2, 5, 6, 7 },
{ 1, 3, 4, 5, 6 },{ 1, 3, 4, 5, 7 },
{ 1, 3, 4, 6, 7 },
{ 1, 3, 5, 6, 7 },
{ 1, 4, 5, 6, 7 },
{ 2, 3, 4, 5, 6 },{ 2, 3, 4, 5, 7 },
{ 2, 3, 4, 6, 7 },
{ 2, 3, 5, 6, 7 },
{ 2, 4, 5, 6, 7 },
{ 3, 4, 5, 6, 7 }
};

int index6[28][6] = {
	{ 0, 1, 2, 3, 4, 5 },{ 0, 1, 2, 3, 4, 6 },{ 0, 1, 2, 3, 4, 7 },
{ 0, 1, 2, 3, 5, 6 },{ 0, 1, 2, 3, 5, 7 },
{ 0, 1, 2, 3, 6, 7 },
{ 0, 1, 2, 4, 5, 6 },{ 0, 1, 2, 4, 5, 7 },
{ 0, 1, 2, 4, 6, 7 },
{ 0, 1, 2, 5, 6, 7 },
{ 0, 1, 3, 4, 5, 6 },{ 0, 1, 3, 4, 5, 7 },
{ 0, 1, 3, 4, 6, 7 },
{ 0, 1, 3, 5, 6, 7 },
{ 0, 1, 4, 5, 6, 7 },
{ 0, 2, 3, 4, 5, 6 },{ 0, 2, 3, 4, 5, 7 },
{ 0, 2, 3, 4, 6, 7 },
{ 0, 2, 3, 5, 6, 7 },
{ 0, 2, 4, 5, 6, 7 },
{ 0, 3, 4, 5, 6, 7 },
{ 1, 2, 3, 4, 5, 6 },{ 1, 2, 3, 4, 5, 7 },
{ 1, 2, 3, 4, 6, 7 },
{ 1, 2, 3, 5, 6, 7 },
{ 1, 2, 4, 5, 6, 7 },
{ 1, 3, 4, 5, 6, 7 },
{ 2, 3, 4, 5, 6, 7 }
};

int index7[8][7] = {
	{ 0, 1, 2, 3, 4, 5, 6 },
{ 0, 1, 2, 3, 4, 5, 7 },
{ 0, 1, 2, 3, 4, 6, 7 },
{ 0, 1, 2, 3, 5, 6, 7 },
{ 0, 1, 2, 4, 5, 6, 7 },
{ 0, 1, 3, 4, 5, 6, 7 },
{ 0, 2, 3, 4, 5, 6, 7 },
{ 1, 2, 3, 4, 5, 6, 7 }
};

int index8[1][8] = {
	{ 0, 1, 2, 3, 4, 5, 6, 7 }
};

int solution(vector<vector<string>> relation) {
	int answer = 0;
	int dCnt = relation.size();
	int tuple = relation[0].size();

	// 1개의 키 중에 Candidate Key를 먼저 넣는다.
	for (int i = 0; i<tuple; i++) {
		// i번째 키의 Candidate Key 여부를 파악한다.
		// relation[j][i]를 temp에 넣고 temp정렬해서 같은거 안나오면 탐색 성공! CKey에 넣는다.
		vector<string> temp;
		for (int j = 0; j<dCnt; j++) temp.push_back(relation[j][i]);
		sort(temp.begin(), temp.end());

		int _check = 0;
		for (int j = 0; j<temp.size() - 1; j++)
			if (temp[j] == temp[j + 1]) {
				_check = 1; break;
			}
		if (!_check) {
			vector<int> t_CKey;
			t_CKey.push_back(i);
			CKey.push_back(t_CKey);
		}
	}

	// 튜플의 조합이 k개인 경우에 대해 판별하는 작업
	for (int i = 0; i<28; i++) {
		vector<vector<string>> temp;
		for (int j = 0; j<dCnt; j++) {
			vector<string> t_temp;
			for (int k = 0; k<2; k++) {
				if (index2[i][k] >= tuple) continue;
				t_temp.push_back(relation[j][index2[i][k]]);
			}
			temp.push_back(t_temp);
		}
		sort(temp.begin(), temp.end());

		int _check = 0;
		for (int j = 0; j<temp.size() - 1; j++) {
			int t_Check = 1;
			for (int k = 0; k<temp[j].size(); k++) {
				if (temp[j][k] != temp[j + 1][k]) t_Check = 0;
			}
			if (t_Check) {
				_check = 1; break;
			}
		}
		if (!_check) {
			// 여기서 CKey에 있는지 확인하고, 없는 경우!
			for (int x = 0; x<CKey.size(); x++) {
				if (CKey[x].size() > i - 1) continue;
				int cnt = 0;
				for (int y = 0; y<CKey[x].size(); y++) {
					for (int z = 0; z<2; z++) {
						if (index2[i][z] >= tuple) continue;
						if (CKey[x][y] == index2[i][z]) { cnt++; break; }
					}
					// CKey[x][y]가 index2[i]의 원소를 모두 탐색했는데 같은게 하나라도 있는 경우 cnt++
					// 이렇게 모든 CKey[x]의 y개 원소를 탐색했을 때, cnt가 CKey[x].size()와 같은 경우 요고는 부분키가 있는 경우라 판단하여 해당 index2[i]는 넣지 않는다. -> _check = 1로 바꿔준다.
				}
				if (cnt == CKey[x].size()) _check = 1;
			}
			if (!_check) {
				vector<int> t_CKey;
				for (int k = 0; k<2; k++) {
					if (index2[i][k] >= tuple) continue;
					t_CKey.push_back(index2[i][k]);
				}
				CKey.push_back(t_CKey);
			}
		}

	}

	// CKey에 있는 갯수를 answer에 지정
	answer = CKey.size();

	return answer - 1;
}

/*
1. 벡터 배열을 만들고, 각 벡터에 해당 속성에 대한 데이터를 저장한다.
2. 각 벡터 배열을 정렬한다.
3. 유일한 키를 얻을 수 있다. 해당 키를 찾으면 answer++하고, visited체크한다.

4. 유일한 키를 얻지 못한 애들끼리 조합한다.
조합하는 방식 : 1은 visited가 체크되었다. 2, 3, 4, 5, 6, 7가 남았다고 가정하자.
2를 기준으로 잡고 3한번->확인성공 4한번 5한번 붙여서 정렬 확인
3을 기준으로 잡고 4한번 5한번 붙여서 정렬 확인
4를 기준으로 잡고 5한번 붙여서 정렬 확인
...
조합하는 방식 : (1), (2, 3)은 visited가 체크되었다. 4, 5, 6, 7가 남았다고 가정하자.
4를 기준으로 잡고 위의 방식 재귀.
즉, 시작점과 키의 개수를 매개변수로 전달하여 조합시킨다.

5. 다시 각 벡터 배열을 정렬한다.
6. ...
*/

/*
새로운 방식의 해결방법
vector<string> Column[8];
int solution(vector<vector<string>> relation) {
int answer = 0;
int dSize = relation.size();
int cSize = relation[0].size();

// 1. 각 칼럼 당 데이터를 Column에 저장. 즉, Column[i]에는 i Column에 해당하는 데이터가 저장된다.
for(int i=0; i<dSize; i++)
for(int j=0; j<cSize; j++)
Column[j].push_back(relation[i][j]);

// 2. 각 벡터 배열을 정렬한다.
for(int i=0; i<cSize; i++)
sort(Column[i].begin(), Column[i].end());

// 3. i개의 칼럼 조합을 사용하여 비교 분석한다.


return answer;
}
*/